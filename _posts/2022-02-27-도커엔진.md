## 2.1 도커 이미지와 컨테이너

도커 엔진에 기본 단위인 이미지, 컨테이너

### 2.1.1 도커 이미지

이미지는 컨테이너를 생성할 때 필요한 요소, iso 파일과 비슷한 개념 이미지는 여러 개층으로 된 바이너리 파일로 존재 컨테이너를 생성하고 읽기 전용으로 사용됨

[저장소이름]/[이미지이름]/[태그] 형태로 구성

- 저장소: 이미지가 저장된 장소를 의미 default는 도커 허브
- 이미지 이름: 어떤 역활을 하는지 나타냄

### 2.1.2 도커 컨테이너

각종 OS, WebServer, DB, 빅데이터 분석툴 등의 이미지를 생성하면 이미지에 목적에 맞는 파일이 들어있는 파일시스템과 격리된 공간의 시스템 자원 및 네트워크를 사용할 수 있는데 이곳을 컨테이너라고 부름 .

## 2.2 도커 컨테이너 다루기

### 2.2.1 컨테이너 생성

```bash
docker -v  # 도커 버전

docker run -i -t ubuntu:18.04 # 도커 이미지 파일 구동(컨테이너 시작) 입출력을 가능하게함 
```

컨테이너 생성될시 ID 값으로 고유한 컨테이너 16진수 해시 값을 생성함

### 2.2.2 컨테이너 목록 확인

CentOS 컨테이너에서 호스트로 되돌아와 지금까지 생성한 컨테이너의 목록을 확인함

```bash
docker ps 컨테이너 목록 생성
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
9e05a1d2c183   ubuntu:18.04            "bash"                   8 seconds ago    Exited (0) 7 seconds ago                                                   magical_mccarthy
```

- CONTAINER ID: 컨테이너에게 자동으로 할당되는 고유한 ID입니다. 위 출력 결과에서는 ID의 일부분밖에 확인할 수 없지만 컨테이너의 정보를 확인하기 위해 docker inspect 명령어를 사용하면 전체 ID를 확인 할 수있음
- IMAGE: 생성할 때 사용된 이미지 이름
- COMMAND: 커맨드는 컨테이너가 시작될 때 실행될 명령어
- CREATE: 컨테이너가 생성되고 난 뒤 시간
- STATUS: 컨테이너 상태
- PORTS: 개방된 포트 목록을 나열
- NAMES: 컨테이너의 고유한 이름 docker rename명령으로 변경 가능

### 2.2.3 컨테이너 삭제

컨테이너를 삭제할 때 사용하는 명령

docker rm container_id

실행중인 컨테이너는 삭제할 수 없어 stop 후 삭제하거나  -f옵션을 추가해 삭제해야함

docker container prune stop되어 있는 모든 상태의 컨테이너를 삭제

```bash
docker container prune # stop되어 있는 모든 상태의 컨테이너를 삭제
```

docker ps 명렁어의 -a 옵션과 -q 옵션을 조합해 삭제 가능

-a 모든 컨테이너 상태와 관계 없이 모든 컨테이너를 -q는 컨테이너 ID만 출력하는 역활

```bash
docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
```

### 2.2.4 컨테이너를 외부에 노출

컨테이너는 가상 머신과 마찬가지로 가상 IP주소를 할당받음

기본적으로 172.17.0.x 의 IP를 순차적으로 할당함

아무런 설정을하지 않았다면 컨테이너는 외부에서 접근할 수 없으며 도커가 설치된 호스트에서만 접근 할 수있음 외부에서 접근하기 위해서는 포트를 바인딩해줘야 한다

```bash
docker run -i -t -p 80:80 unbuntu:18.04
```

### 2.2.5 컨테이너 애플리케이션 구축

여러 에이전트나 데이터베이스 등과 연결되어 완전한 서비스로써 동작하는 것이 일반적인데 이런 서비스를 컨테이너 화 할때 여러 애플리케이션을 한 컨테이너에 설치할 수도 있고 애플리케이션을 하나만 동작시켜 컨테이너 간의 독립성을 보장 시킬 수 있음.

기타 예제 교제 참조

간략 > docker run -i -t  포그라운드 모드 터미널이 종료되면 종료

docker run -d 백그라운드모드 터미널이 종료되더라도 컨테이너가 실행 유지

docker attch 명령어로  접근할 시 터미널이 미러링됨

—link 옵션을 통해 네트워크 링크를 맺을 수 있음

### 2.2.6 도커 볼륨

도커 컨테이너를 생성하면 읽기 전용이 되며 컨테이너 변경사항이 각 컨테이너 내부에 정보를 보존 컨테이너를 삭제 될 시 해당 정보도 삭제됨 이를 방지하기 위해 데이터를 영속적으로 활용할 수 있는 방법 중 하나가 볼륨을 사용하는 것

볼륨을 활용하는 방법은 여러가지가 있는데 호스트와 볼륨을 공유할 수 도있꼬 볼륨 컨테이너를 활용 할 수도 있으며 도커가 관리하는 볼륨을 생성할 수도 있습니다.

### 2.2.6.1 호스트 볼륨 공유

```bash
docker run -d 
중략
-v /home/wordpress_db:/var/lib/mysql \\
mysql:5.7
```

/home/wordpress_db 와 /var/lib/mysql 디렉터리를 공유한다는 뜻

[호스트의 공유 디렉터리]:[컨테이너의 공유 디렉터리] 형태

해당 디렉터리에 데이터베이스 관련 파일이 있는지 확인합니다. 필요 파일이 없으면 각종 파일을 생성

또한 단위 파일도 공유 가능하며 동시에 여러개의 -v 옵션을 슬 수도 있습니다.

이미지에 원래 존재하던 디렉터리에 호스트의 볼륨을 공유하면 컨테이너 디렉터리 자체가 덮어씌워짐

호스트 볼륨 공유는 호스트의 디렉터리를 컨테이너 디렉터리에 마운트합니다.

### 2.2.6.2 볼륨 컨테이너

볼륨을 사용하는 두 번째 방법은 -v 옵션으로 볼륨을 사용하는 컨테이너를 다른 컨테이너와 공유하는 것

컨테이너를 생성할 떄 —volumes-from 옵션을 설정하면 -v Ehsms —volum 옵션을 적용하는 컨테이너의 볼륨 디렉터리를 공유할 수 있습니다. 그러나 이는 직접 볼륨을 공유하는 것이 아닌 -v 옵션을 적용한 컨테이를 통해 공유하는 것

```bash
docker run -i -t \\
--name volumes_from_container \\
--volumes-from volume_overide
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3bf020d3-c892-4c3f-aeba-00d00bae05b1/Untitled.png)

여러 개의 컨테이너가 동일한 컨테이너에 —volumes-from 옵션을 사용함으로써 볼륨을 공유해 사용할 수도 있습니다. 이러한 구조를 활용하면 호스트에서 볼륨만 공유하고 별도의 역할을 담당하지 않는 일명 ‘볼륨 컨테이너’로 활용하는것도 가능  볼륨컨테이너에 데이터를 연결해 간접적으로 공유 받는 방식

### 2.2.6.3 도커 볼륨

볼륨을 활용하는 세 번째 방법은 docker volume 명령어를 사용하는 것

도커 자체에서 제공하는 볼륨 기능을 활용해 데이터를 보존할 수도 있음

```bash
docker volume create volume_id  # 도커 볼륨 생성
docker volume ls 
```

볼륨을 생성할 때 플러그인 드라이버를 설정해 여러 종류의 스토리지 백엔드를 쓸 수 있음

[볼륨의 이름]:[컨테이너의 공유 디렉터리]

```bash
docker run -i -t \\
-v volume_id:/root/ \\
ubuntu:18.04
```

도커 볼륨은 디렉터리 하나에 상응하는 단위로서 도커 엔진에서 관리함. 호스트에 저장함으로써 데이터를 보존하지만 파일이 실제로 어디에 저장되는지 사용자는 알 필요가 없음

docker inpect 명령을 통해 실제로 어디에 저장되었는지 확인 할 수 있음.

외부에 데이터를 저장하고 컨테이너는 그 데이터로 동작하도록 설계하는 것을 스테이트리스(stateless)하다고 말함 컨테이너가 삭제돼더라도 데이터는 보존되므로 스테이리스한 컨테이너 설계는 도커를 사용할 떄 매우 바람직한 설계.

이와 반대 명칭은 스테이트풀(stateful) 이라고 함